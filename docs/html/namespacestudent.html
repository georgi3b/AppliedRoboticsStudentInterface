<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robot Planning and its application Project: student Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Robot Planning and its application Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">student Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstudent_1_1configuration.html">configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstudent_1_1dubinsCurve.html">dubinsCurve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstudent_1_1triplet.html">triplet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstudent_1_1adjNode.html">adjNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstudent_1_1graphEdge.html">graphEdge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstudent_1_1graph.html">graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstudent_1_1myMotionValidator.html">myMotionValidator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac7fa28175e545df200c45a9cbf274518"><td class="memItemLeft" align="right" valign="top"><a id="ac7fa28175e545df200c45a9cbf274518"></a>
typedef bg::model::d2::point_xy&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>point_type</b></td></tr>
<tr class="separator:ac7fa28175e545df200c45a9cbf274518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071ca3cb393a194f602ef251efdc5e7b"><td class="memItemLeft" align="right" valign="top"><a id="a071ca3cb393a194f602ef251efdc5e7b"></a>
typedef bg::model::polygon&lt; point_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>polygon_type</b></td></tr>
<tr class="separator:a071ca3cb393a194f602ef251efdc5e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3693d71776252074ce550535378b50d5"><td class="memItemLeft" align="right" valign="top"><a id="a3693d71776252074ce550535378b50d5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>dubins_primitives</b> { <br />
&#160;&#160;<b>LSL</b>
, <b>RSR</b>
, <b>LSR</b>
, <b>RSL</b>
, <br />
&#160;&#160;<b>RLR</b>
, <b>LRL</b>
, <b>MAXIMUM_NUMBER_OF_CURVES</b>
<br />
 }</td></tr>
<tr class="separator:a3693d71776252074ce550535378b50d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5b674b3695610f840b28b97b1bcd82de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a5b674b3695610f840b28b97b1bcd82de">coll_LineLine</a> (double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)</td></tr>
<tr class="separator:a5b674b3695610f840b28b97b1bcd82de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7550d88430bcb695137e5976b94e3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a2d7550d88430bcb695137e5976b94e3a">coll_LineCircle</a> (double x1, double y1, double x2, double y2, <a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a> arc)</td></tr>
<tr class="separator:a2d7550d88430bcb695137e5976b94e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13283ab20308fde8c6f0175f6c2ddf44"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a13283ab20308fde8c6f0175f6c2ddf44">max</a> (double a, double b)</td></tr>
<tr class="separator:a13283ab20308fde8c6f0175f6c2ddf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9321c7b71ce1a4a7ef152d6020c917d5"><td class="memItemLeft" align="right" valign="top"><a id="a9321c7b71ce1a4a7ef152d6020c917d5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (double a, double b)</td></tr>
<tr class="separator:a9321c7b71ce1a4a7ef152d6020c917d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1683a6357c9495deae1b46f1f23d716e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a1683a6357c9495deae1b46f1f23d716e">cross2D</a> (double M_00, double M_01, double M_10, double M_11)</td></tr>
<tr class="separator:a1683a6357c9495deae1b46f1f23d716e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab33418a119017635f5f69558fd7c43"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a1ab33418a119017635f5f69558fd7c43">dot2D</a> (double M_00, double M_01, double M_10, double M_11)</td></tr>
<tr class="separator:a1ab33418a119017635f5f69558fd7c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c29d7d15cf5e0736336cb908aaf0c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a7c29d7d15cf5e0736336cb908aaf0c71">plotXLine</a> (bool res, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)</td></tr>
<tr class="separator:a7c29d7d15cf5e0736336cb908aaf0c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f733020135d62f2caa53a28210869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a218f733020135d62f2caa53a28210869">plotXCircle</a> (bool res, double x1, double y1, double x2, double y2, double xC, double yC, double radius, cv::Point a1, cv::Point a2, double verse)</td></tr>
<tr class="separator:a218f733020135d62f2caa53a28210869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac357295a3e0a58316ce8884b898963be"><td class="memItemLeft" align="right" valign="top"><a id="ac357295a3e0a58316ce8884b898963be"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac357295a3e0a58316ce8884b898963be">sinc</a> (double x)</td></tr>
<tr class="memdesc:ac357295a3e0a58316ce8884b898963be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sinc with Taylor series approximation, used to check correctness of solution. <br /></td></tr>
<tr class="separator:ac357295a3e0a58316ce8884b898963be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04dc56712a80369cb1e11b6a5949f11"><td class="memItemLeft" align="right" valign="top"><a id="ac04dc56712a80369cb1e11b6a5949f11"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac04dc56712a80369cb1e11b6a5949f11">mod2pi</a> (double angle)</td></tr>
<tr class="memdesc:ac04dc56712a80369cb1e11b6a5949f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an angle, [0, 2*PI) (can be useful for findRobot as well) <br /></td></tr>
<tr class="separator:ac04dc56712a80369cb1e11b6a5949f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb63c2f209d6eab72af17735e25b5201"><td class="memItemLeft" align="right" valign="top"><a id="afb63c2f209d6eab72af17735e25b5201"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#afb63c2f209d6eab72af17735e25b5201">rangeSymm</a> (double angle)</td></tr>
<tr class="memdesc:afb63c2f209d6eab72af17735e25b5201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an angular difference (range (-pi, pi]) <br /></td></tr>
<tr class="separator:afb63c2f209d6eab72af17735e25b5201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a7551fd4d068a2400a7398e2f7bd3f"><td class="memItemLeft" align="right" valign="top"><a id="a43a7551fd4d068a2400a7398e2f7bd3f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a43a7551fd4d068a2400a7398e2f7bd3f">check</a> (double s1, double k0, double s2, double k1, double s3, double k2, double th0, double thf)</td></tr>
<tr class="memdesc:a43a7551fd4d068a2400a7398e2f7bd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the correctness of a Dubin's solution by taking as input the scaled parameters. <br /></td></tr>
<tr class="separator:a43a7551fd4d068a2400a7398e2f7bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343d9cd6d6fd1747e42374104cee6cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstudent_1_1configuration.html">configuration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a343d9cd6d6fd1747e42374104cee6cba">getNextConfig</a> (<a class="el" href="structstudent_1_1configuration.html">configuration</a> curr, double k, double s)</td></tr>
<tr class="separator:a343d9cd6d6fd1747e42374104cee6cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e804115ed7fd271368146f5cf78fce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a7e804115ed7fd271368146f5cf78fce6">constructArc</a> (<a class="el" href="structstudent_1_1configuration.html">configuration</a> currConf, double k, double L)</td></tr>
<tr class="separator:a7e804115ed7fd271368146f5cf78fce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac881c09e990c34189df7dee9cd43ed39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstudent_1_1dubinsCurve.html">dubinsCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac881c09e990c34189df7dee9cd43ed39">constructDubinsCurve</a> (<a class="el" href="structstudent_1_1configuration.html">configuration</a> initialConf, double s1, double s2, double s3, double k0, double k1, double k2)</td></tr>
<tr class="separator:ac881c09e990c34189df7dee9cd43ed39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614b490c6c0f172cfb9b2e4e5081475"><td class="memItemLeft" align="right" valign="top"><a id="ae614b490c6c0f172cfb9b2e4e5081475"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ae614b490c6c0f172cfb9b2e4e5081475">printConfiguration</a> (<a class="el" href="structstudent_1_1configuration.html">configuration</a> config)</td></tr>
<tr class="memdesc:ae614b490c6c0f172cfb9b2e4e5081475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info about the configuration of the robot (x,y, yaw). <br /></td></tr>
<tr class="separator:ae614b490c6c0f172cfb9b2e4e5081475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04925f5e7d32b35d2dcfddada4700917"><td class="memItemLeft" align="right" valign="top"><a id="a04925f5e7d32b35d2dcfddada4700917"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a04925f5e7d32b35d2dcfddada4700917">printArc</a> (<a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a> arc)</td></tr>
<tr class="memdesc:a04925f5e7d32b35d2dcfddada4700917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info about arcs that compose the Dubin's Curve. <br /></td></tr>
<tr class="separator:a04925f5e7d32b35d2dcfddada4700917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbae8965481236d070acd985a858dbb6"><td class="memItemLeft" align="right" valign="top"><a id="acbae8965481236d070acd985a858dbb6"></a>
std::chrono::high_resolution_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#acbae8965481236d070acd985a858dbb6">startTime</a> ()</td></tr>
<tr class="memdesc:acbae8965481236d070acd985a858dbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this moment in time. <br /></td></tr>
<tr class="separator:acbae8965481236d070acd985a858dbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18abd9a1eb16a0a5da711c37d1be60e"><td class="memItemLeft" align="right" valign="top"><a id="ae18abd9a1eb16a0a5da711c37d1be60e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ae18abd9a1eb16a0a5da711c37d1be60e">stopTime</a> (std::chrono::high_resolution_clock::time_point start, bool unit)</td></tr>
<tr class="memdesc:ae18abd9a1eb16a0a5da711c37d1be60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the start moment and tells how much time passed between that and now. <br /></td></tr>
<tr class="separator:ae18abd9a1eb16a0a5da711c37d1be60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11644897731eda6b93e6335de865c59"><td class="memItemLeft" align="right" valign="top"><a id="ae11644897731eda6b93e6335de865c59"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ae11644897731eda6b93e6335de865c59">scaleToStandard</a> (<a class="el" href="structstudent_1_1configuration.html">configuration</a> initial, <a class="el" href="structstudent_1_1configuration.html">configuration</a> final, double kmax, double &amp;scTh0, double &amp;scThf, double &amp;scKmax, double &amp;lambda)</td></tr>
<tr class="memdesc:ae11644897731eda6b93e6335de865c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale path finding problem into (-1,0) - (1,0) range. <br /></td></tr>
<tr class="separator:ae11644897731eda6b93e6335de865c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a4d92c94017de500472c4363b498c9"><td class="memItemLeft" align="right" valign="top"><a id="ad4a4d92c94017de500472c4363b498c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ad4a4d92c94017de500472c4363b498c9">scaleFromStandard</a> (double lambda, double sc_s1, double sc_s2, double sc_s3, double &amp;s1, double &amp;s2, double &amp;s3)</td></tr>
<tr class="memdesc:ad4a4d92c94017de500472c4363b498c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the solution to the standard problem back to the original problem. <br /></td></tr>
<tr class="separator:ad4a4d92c94017de500472c4363b498c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f21f358569ce086b2be919cd3c7607"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a80f21f358569ce086b2be919cd3c7607">dubins_LSL</a> (double sc_th0, double sc_thf, double sc_Kmax, double &amp;sc_s1, double &amp;sc_s2, double &amp;sc_s3)</td></tr>
<tr class="separator:a80f21f358569ce086b2be919cd3c7607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79074a60055dba829304da1ba43cfdfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a79074a60055dba829304da1ba43cfdfb">dubins_RSR</a> (double sc_th0, double sc_thf, double sc_Kmax, double &amp;sc_s1, double &amp;sc_s2, double &amp;sc_s3)</td></tr>
<tr class="separator:a79074a60055dba829304da1ba43cfdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255f1fd6ee3a8a404469459c51fd8e76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a255f1fd6ee3a8a404469459c51fd8e76">dubins_LSR</a> (double sc_th0, double sc_thf, double sc_Kmax, double &amp;sc_s1, double &amp;sc_s2, double &amp;sc_s3)</td></tr>
<tr class="separator:a255f1fd6ee3a8a404469459c51fd8e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1e4d5c3ea5d2032812cce24ac5a479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ada1e4d5c3ea5d2032812cce24ac5a479">dubins_RSL</a> (double sc_th0, double sc_thf, double sc_Kmax, double &amp;sc_s1, double &amp;sc_s2, double &amp;sc_s3)</td></tr>
<tr class="separator:ada1e4d5c3ea5d2032812cce24ac5a479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc22c326309c1c531da2d15d271e009c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#acc22c326309c1c531da2d15d271e009c">dubins_RLR</a> (double sc_th0, double sc_thf, double sc_Kmax, double &amp;sc_s1, double &amp;sc_s2, double &amp;sc_s3)</td></tr>
<tr class="separator:acc22c326309c1c531da2d15d271e009c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa356091fcb55ee1924e097c9c97129a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aa356091fcb55ee1924e097c9c97129a1">dubins_LRL</a> (double sc_th0, double sc_thf, double sc_Kmax, double &amp;sc_s1, double &amp;sc_s2, double &amp;sc_s3)</td></tr>
<tr class="separator:aa356091fcb55ee1924e097c9c97129a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16c5106a18eaaea0d105ba30403eedd"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, <a class="el" href="structstudent_1_1dubinsCurve.html">dubinsCurve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ad16c5106a18eaaea0d105ba30403eedd">dubins_shortest_path</a> (<a class="el" href="structstudent_1_1configuration.html">configuration</a> initial, <a class="el" href="structstudent_1_1configuration.html">configuration</a> final, double Kmax)</td></tr>
<tr class="separator:ad16c5106a18eaaea0d105ba30403eedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eabf8488e510a598c21787bb66cfea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstudent_1_1dubinsCurve.html">dubinsCurve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a37eabf8488e510a598c21787bb66cfea">multipoint</a> (const <a class="el" href="structstudent_1_1configuration.html">configuration</a> &amp;robot, std::vector&lt; Point &gt; &amp;points, double gate_th)</td></tr>
<tr class="separator:a37eabf8488e510a598c21787bb66cfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad425975095ed9cfa9bb01a275f15f32a"><td class="memItemLeft" align="right" valign="top"><a id="ad425975095ed9cfa9bb01a275f15f32a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>plot</b> (cv::Mat image, double **pts_1, cv::Scalar c1, double **pts_2, cv::Scalar c2, double **pts_3, cv::Scalar c3)</td></tr>
<tr class="separator:ad425975095ed9cfa9bb01a275f15f32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbb6825a0763a87837133d4c2bb2fc5"><td class="memItemLeft" align="right" valign="top"><a id="a6fbb6825a0763a87837133d4c2bb2fc5"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>get_arc_points</b> (<a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a> arc, int npts)</td></tr>
<tr class="separator:a6fbb6825a0763a87837133d4c2bb2fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af078e298febf8de3fa6c787b163e4e44"><td class="memItemLeft" align="right" valign="top"><a id="af078e298febf8de3fa6c787b163e4e44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>plot_dubins</b> (std::vector&lt; <a class="el" href="structstudent_1_1dubinsCurve.html">dubinsCurve</a> &gt; curves)</td></tr>
<tr class="separator:af078e298febf8de3fa6c787b163e4e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540784e0ef9fac7b3f5ed24aa8a1f93d"><td class="memItemLeft" align="right" valign="top"><a id="a540784e0ef9fac7b3f5ed24aa8a1f93d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printAdjList</b> (<a class="el" href="structstudent_1_1adjNode.html">adjNode</a> *ptr, int i)</td></tr>
<tr class="separator:a540784e0ef9fac7b3f5ed24aa8a1f93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40970d4d45d273f2571d70f5e75a054"><td class="memItemLeft" align="right" valign="top">Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ae40970d4d45d273f2571d70f5e75a054">getCenter</a> (const Polygon &amp;poly)</td></tr>
<tr class="separator:ae40970d4d45d273f2571d70f5e75a054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c480ab8ffeff46887387b8b54c4dcb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a6c480ab8ffeff46887387b8b54c4dcb9">myStateValidityCheckerFunction</a> (const ob::State *state)</td></tr>
<tr class="separator:a6c480ab8ffeff46887387b8b54c4dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b31fbfd67fbf04c6e71e71a7cef417c"><td class="memItemLeft" align="right" valign="top"><a id="a3b31fbfd67fbf04c6e71e71a7cef417c"></a>
ob::ValidStateSamplerPtr&#160;</td><td class="memItemRight" valign="bottom"><b>allocOBValidStateSampler</b> (const ob::SpaceInformation *si)</td></tr>
<tr class="separator:a3b31fbfd67fbf04c6e71e71a7cef417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9b35f6b5dad47513757e4211a5bcbe"><td class="memItemLeft" align="right" valign="top"><a id="a3f9b35f6b5dad47513757e4211a5bcbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawSolutionTree</b> (std::vector&lt; Point &gt; RRT_list, cv::Mat &amp;image)</td></tr>
<tr class="separator:a3f9b35f6b5dad47513757e4211a5bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d208aba3d19c6988ed675165bfe44e"><td class="memItemLeft" align="right" valign="top"><a id="a84d208aba3d19c6988ed675165bfe44e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>gate_angle</b> (const Polygon &amp;gate, const Polygon &amp;arena, double &amp;gate_mid_w, double &amp;gate_mid_h)</td></tr>
<tr class="separator:a84d208aba3d19c6988ed675165bfe44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e78c9c1bb3fcd9536f328335d64def"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#af0e78c9c1bb3fcd9536f328335d64def">missionTwo</a> (std::shared_ptr&lt; ompl::base::SpaceInformation &gt; si, std::vector&lt; Point &gt; &amp;point_list)</td></tr>
<tr class="separator:af0e78c9c1bb3fcd9536f328335d64def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfea618c10c13f73ac9e6ddca052db2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aabfea618c10c13f73ac9e6ddca052db2">missionOne</a> (std::vector&lt; Point &gt; &amp;point_list, std::vector&lt; Point &gt; &amp;RRT_list, std::shared_ptr&lt; ompl::base::SpaceInformation &gt; si, std::shared_ptr&lt; ob::SE2StateSpace &gt; space, cv::Mat &amp;image)</td></tr>
<tr class="separator:aabfea618c10c13f73ac9e6ddca052db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43029d54847618c772ba6ae1a933da78"><td class="memItemLeft" align="right" valign="top"><a id="a43029d54847618c772ba6ae1a933da78"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a43029d54847618c772ba6ae1a933da78">find_closest</a> (Point &amp;self, std::vector&lt; Point &gt; &amp;samples)</td></tr>
<tr class="memdesc:a43029d54847618c772ba6ae1a933da78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the point closest to a given point. <br /></td></tr>
<tr class="separator:a43029d54847618c772ba6ae1a933da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e03cabaecd9d8cef67f5d5f5aa628d9"><td class="memItemLeft" align="right" valign="top"><a id="a7e03cabaecd9d8cef67f5d5f5aa628d9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a7e03cabaecd9d8cef67f5d5f5aa628d9">distance</a> (Point &amp;a, Point &amp;b)</td></tr>
<tr class="memdesc:a7e03cabaecd9d8cef67f5d5f5aa628d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an euclidean distance. <br /></td></tr>
<tr class="separator:a7e03cabaecd9d8cef67f5d5f5aa628d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e0aecde54620c30d46a5dcc6c9fb7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aa3e0aecde54620c30d46a5dcc6c9fb7a">student_planPath</a> (const Polygon &amp;borders, const std::vector&lt; Polygon &gt; &amp;obstacle_list, const std::vector&lt; std::pair&lt; int, Polygon &gt;&gt; &amp;victim_list, const Polygon &amp;gate, const float x, const float y, const float theta, Path &amp;path, const std::string &amp;config_folder)</td></tr>
<tr class="separator:aa3e0aecde54620c30d46a5dcc6c9fb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8c9cb0a117359291d6800b0dd9461f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a3c8c9cb0a117359291d6800b0dd9461f">student_loadImage</a> (cv::Mat &amp;img_out, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a3c8c9cb0a117359291d6800b0dd9461f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9056dc07d30ae7657be42b03dfe3a2a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a9056dc07d30ae7657be42b03dfe3a2a0">student_genericImageListener</a> (const cv::Mat &amp;img_in, std::string topic, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a9056dc07d30ae7657be42b03dfe3a2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187cfd6d82aaffa5c634c4ef24271f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a187cfd6d82aaffa5c634c4ef24271f7d">student_imageUndistort</a> (const cv::Mat &amp;img_in, cv::Mat &amp;img_out, const cv::Mat &amp;cam_matrix, const cv::Mat &amp;dist_coeffs, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a187cfd6d82aaffa5c634c4ef24271f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d70460143a4151dd1ef09ee21bbe767"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a4d70460143a4151dd1ef09ee21bbe767">student_extrinsicCalib</a> (const cv::Mat &amp;img_in, std::vector&lt; cv::Point3f &gt; object_points, const cv::Mat &amp;camera_matrix, cv::Mat &amp;rvec, cv::Mat &amp;tvec, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a4d70460143a4151dd1ef09ee21bbe767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41af80cd00041a3f7159a5d3f4fb6116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a41af80cd00041a3f7159a5d3f4fb6116">student_findPlaneTransform</a> (const cv::Mat &amp;cam_matrix, const cv::Mat &amp;rvec, const cv::Mat &amp;tvec, const std::vector&lt; cv::Point3f &gt; &amp;object_points_plane, const std::vector&lt; cv::Point2f &gt; &amp;dest_image_points_plane, cv::Mat &amp;plane_transf, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a41af80cd00041a3f7159a5d3f4fb6116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b33d29b9e4396350ed75aac2ef2d3ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a7b33d29b9e4396350ed75aac2ef2d3ce">student_unwarp</a> (const cv::Mat &amp;img_in, cv::Mat &amp;img_out, const cv::Mat &amp;transf, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a7b33d29b9e4396350ed75aac2ef2d3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e9d0633e36ea78c4bb946f593c8f8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a04e9d0633e36ea78c4bb946f593c8f8e">student_findRobot</a> (const cv::Mat &amp;img_in, const double scale, Polygon &amp;triangle, double &amp;x, double &amp;y, double &amp;theta, const std::string &amp;config_folder, const bool DEBUG)</td></tr>
<tr class="separator:a04e9d0633e36ea78c4bb946f593c8f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261bfa62778cb6adf492f7d50827da78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a261bfa62778cb6adf492f7d50827da78">student_processMap</a> (const cv::Mat &amp;img_in, const double scale, std::vector&lt; Polygon &gt; &amp;obstacle_list, std::vector&lt; std::pair&lt; int, Polygon &gt;&gt; &amp;victim_list, Polygon &amp;gate, const std::string &amp;config_folder, const bool DEBUG)</td></tr>
<tr class="separator:a261bfa62778cb6adf492f7d50827da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe064aafb1dcccadf8d38ebc0457aa05"><td class="memItemLeft" align="right" valign="top"><a id="abe064aafb1dcccadf8d38ebc0457aa05"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_arc_points</b> (double **pts, <a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a> arc, int npts)</td></tr>
<tr class="separator:abe064aafb1dcccadf8d38ebc0457aa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3117c968a47bf95f86bdb813a3b64e56"><td class="memItemLeft" align="right" valign="top"><a id="a3117c968a47bf95f86bdb813a3b64e56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadImage</b> (cv::Mat &amp;img_out, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a3117c968a47bf95f86bdb813a3b64e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b726e7af03a643c06dcde23057a82ea"><td class="memItemLeft" align="right" valign="top"><a id="a3b726e7af03a643c06dcde23057a82ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>genericImageListener</b> (const cv::Mat &amp;img_in, std::string topic, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a3b726e7af03a643c06dcde23057a82ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6103f938ce28f8820c48c089d5f95098"><td class="memItemLeft" align="right" valign="top"><a id="a6103f938ce28f8820c48c089d5f95098"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>extrinsicCalib</b> (const cv::Mat &amp;img_in, std::vector&lt; cv::Point3f &gt; object_points, const cv::Mat &amp;camera_matrix, cv::Mat &amp;rvec, cv::Mat &amp;tvec, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a6103f938ce28f8820c48c089d5f95098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb2a29362b8223a9d3601d9496e1c98"><td class="memItemLeft" align="right" valign="top"><a id="aceb2a29362b8223a9d3601d9496e1c98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>imageUndistort</b> (const cv::Mat &amp;img_in, cv::Mat &amp;img_out, const cv::Mat &amp;cam_matrix, const cv::Mat &amp;dist_coeffs, const std::string &amp;config_folder)</td></tr>
<tr class="separator:aceb2a29362b8223a9d3601d9496e1c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528d33658d0d4d982a46f18b7abb4a70"><td class="memItemLeft" align="right" valign="top"><a id="a528d33658d0d4d982a46f18b7abb4a70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findPlaneTransform</b> (const cv::Mat &amp;cam_matrix, const cv::Mat &amp;rvec, const cv::Mat &amp;tvec, const std::vector&lt; cv::Point3f &gt; &amp;object_points_plane, const std::vector&lt; cv::Point2f &gt; &amp;dest_image_points_plane, cv::Mat &amp;plane_transf, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a528d33658d0d4d982a46f18b7abb4a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8caf348979f55e58a75193233c219d"><td class="memItemLeft" align="right" valign="top"><a id="a6b8caf348979f55e58a75193233c219d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unwarp</b> (const cv::Mat &amp;img_in, cv::Mat &amp;img_out, const cv::Mat &amp;transf, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a6b8caf348979f55e58a75193233c219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a17ef667d7c10b8f33d815b9bc1bc"><td class="memItemLeft" align="right" valign="top"><a id="a153a17ef667d7c10b8f33d815b9bc1bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>processMap</b> (const cv::Mat &amp;img_in, const double scale, std::vector&lt; Polygon &gt; &amp;obstacle_list, std::vector&lt; std::pair&lt; int, Polygon &gt;&gt; &amp;victim_list, Polygon &amp;gate, const std::string &amp;config_folder)</td></tr>
<tr class="separator:a153a17ef667d7c10b8f33d815b9bc1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd56b779672a672e15ac45dc927b8a6b"><td class="memItemLeft" align="right" valign="top"><a id="afd56b779672a672e15ac45dc927b8a6b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>findRobot</b> (const cv::Mat &amp;img_in, const double scale, Polygon &amp;triangle, double &amp;x, double &amp;y, double &amp;theta, const std::string &amp;config_folder)</td></tr>
<tr class="separator:afd56b779672a672e15ac45dc927b8a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe62076a49d23bb083f2f880fd24c77"><td class="memItemLeft" align="right" valign="top"><a id="acfe62076a49d23bb083f2f880fd24c77"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>planPath</b> (const Polygon &amp;borders, const std::vector&lt; Polygon &gt; &amp;obstacle_list, const std::vector&lt; std::pair&lt; int, Polygon &gt;&gt; &amp;victim_list, const Polygon &amp;gate, const float x, const float y, const float theta, Path &amp;path, const std::string &amp;config_folder)</td></tr>
<tr class="separator:acfe62076a49d23bb083f2f880fd24c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f1d6c8dd4caa817efc0cd3c46eb2e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ab3f1d6c8dd4caa817efc0cd3c46eb2e0">mouseCallback</a> (int event, int x, int y, int, void *p)</td></tr>
<tr class="separator:ab3f1d6c8dd4caa817efc0cd3c46eb2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01244e0e0a28d974de100ffcad7a2583"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point2f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a01244e0e0a28d974de100ffcad7a2583">pickNPoints</a> (int n0, const cv::Mat &amp;img)</td></tr>
<tr class="separator:a01244e0e0a28d974de100ffcad7a2583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a53db039172e2b837294b6c1fc0da9d"><td class="memItemLeft" align="right" valign="top"><a id="a5a53db039172e2b837294b6c1fc0da9d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a5a53db039172e2b837294b6c1fc0da9d">processGreen</a> (const cv::Mat &amp;img_hsv, cv::Mat &amp;green_mask, bool DEBUG)</td></tr>
<tr class="memdesc:a5a53db039172e2b837294b6c1fc0da9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to process the green color of the image that comes from the simulator. <br /></td></tr>
<tr class="separator:a5a53db039172e2b837294b6c1fc0da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f50d3d0d74de628aee5793485bdca3"><td class="memItemLeft" align="right" valign="top"><a id="ac7f50d3d0d74de628aee5793485bdca3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac7f50d3d0d74de628aee5793485bdca3">processObstacles</a> (const cv::Mat &amp;img_in, const cv::Mat &amp;img_hsv, const double scale, std::vector&lt; Polygon &gt; &amp;obstacle_list, bool DEBUG)</td></tr>
<tr class="memdesc:ac7f50d3d0d74de628aee5793485bdca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the red obstacles and saves them in the obstacle_list. <br /></td></tr>
<tr class="separator:ac7f50d3d0d74de628aee5793485bdca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1731194eb6c5da34057e2fdf703cf708"><td class="memItemLeft" align="right" valign="top"><a id="a1731194eb6c5da34057e2fdf703cf708"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a1731194eb6c5da34057e2fdf703cf708">processBorders</a> (const cv::Mat &amp;img_in, const cv::Mat &amp;img_hsv, const double scale, std::vector&lt; Polygon &gt; &amp;obstacle_list, bool DEBUG)</td></tr>
<tr class="memdesc:a1731194eb6c5da34057e2fdf703cf708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the black borders of the arena and treats them as trapezoidal obstacles. <br /></td></tr>
<tr class="separator:a1731194eb6c5da34057e2fdf703cf708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54be2d174756e688e7ab0a2a82919893"><td class="memItemLeft" align="right" valign="top"><a id="a54be2d174756e688e7ab0a2a82919893"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a54be2d174756e688e7ab0a2a82919893">processGate</a> (const cv::Mat &amp;img_hsv, cv::Mat &amp;green_mask, const double scale, Polygon &amp;gate, std::vector&lt; Polygon &gt; &amp;off_borders, bool DEBUG)</td></tr>
<tr class="memdesc:a54be2d174756e688e7ab0a2a82919893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the green gate. <br /></td></tr>
<tr class="separator:a54be2d174756e688e7ab0a2a82919893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581cf472361fdc3d816722f312f0c173"><td class="memItemLeft" align="right" valign="top"><a id="a581cf472361fdc3d816722f312f0c173"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a581cf472361fdc3d816722f312f0c173">processVictims</a> (const cv::Mat &amp;img_in, const cv::Mat &amp;img_hsv, cv::Mat &amp;green_mask, const double scale, std::vector&lt; std::pair&lt; int, Polygon &gt;&gt; &amp;victim_list, bool DEBUG)</td></tr>
<tr class="memdesc:a581cf472361fdc3d816722f312f0c173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the green circles that correspond to the victims, to collect their position and their id. <br /></td></tr>
<tr class="separator:a581cf472361fdc3d816722f312f0c173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2608eef8e596c047d66f356948e8aeb3"><td class="memItemLeft" align="right" valign="top"><a id="a2608eef8e596c047d66f356948e8aeb3"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a2608eef8e596c047d66f356948e8aeb3">findRobotRadius</a> (const cv::Mat &amp;img_in, const cv::Mat &amp;img_hsv, const double scale, bool DEBUG)</td></tr>
<tr class="memdesc:a2608eef8e596c047d66f356948e8aeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the blue triangle of the robot to find the radius of the circle, in order to perform the offset. <br /></td></tr>
<tr class="separator:a2608eef8e596c047d66f356948e8aeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c34fd357e9aea63dd5181ab6badcdc"><td class="memItemLeft" align="right" valign="top"><a id="a12c34fd357e9aea63dd5181ab6badcdc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a12c34fd357e9aea63dd5181ab6badcdc">offsetObstacles</a> (const float OFFSET, const cv::Mat &amp;img_in, const double scale, const std::vector&lt; Polygon &gt; &amp;found_obstacles, std::vector&lt; Polygon &gt; &amp;offsetted_obstacles, const bool DEBUG)</td></tr>
<tr class="memdesc:a12c34fd357e9aea63dd5181ab6badcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses Clipper to offset the found_obstacles all together, returing a list of processed_obstacles where they are merged. <br /></td></tr>
<tr class="separator:a12c34fd357e9aea63dd5181ab6badcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc638b6ddc6f6380953a2a4f0727883"><td class="memItemLeft" align="right" valign="top"><a id="a7cc638b6ddc6f6380953a2a4f0727883"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a7cc638b6ddc6f6380953a2a4f0727883">offsetEachObstacle</a> (const float OFFSET, const cv::Mat &amp;img_in, const double scale, std::vector&lt; Polygon &gt; &amp;found_obstacles, std::vector&lt; Polygon &gt; &amp;offsetted_obstacles, const bool DEBUG)</td></tr>
<tr class="memdesc:a7cc638b6ddc6f6380953a2a4f0727883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets each obstacle in found_obstacles at a time by using the Clipper library. <br /></td></tr>
<tr class="separator:a7cc638b6ddc6f6380953a2a4f0727883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0197bd1e3fcf8ee1faadaef7e582c1b"><td class="memItemLeft" align="right" valign="top"><a id="ad0197bd1e3fcf8ee1faadaef7e582c1b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ad0197bd1e3fcf8ee1faadaef7e582c1b">findTemplateId</a> (cv::Mat &amp;processROI, std::vector&lt; cv::Mat &gt; &amp;templates, bool DEBUG)</td></tr>
<tr class="memdesc:ad0197bd1e3fcf8ee1faadaef7e582c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a region of an image against the number templates, and returns the id of the best match. <br /></td></tr>
<tr class="separator:ad0197bd1e3fcf8ee1faadaef7e582c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bdf2fadfcf7a12d2a22d4b0136a56d"><td class="memItemLeft" align="right" valign="top"><a id="ae9bdf2fadfcf7a12d2a22d4b0136a56d"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ae9bdf2fadfcf7a12d2a22d4b0136a56d">rotate</a> (cv::Mat src, double angle)</td></tr>
<tr class="memdesc:ae9bdf2fadfcf7a12d2a22d4b0136a56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to rotate a part of an image by a certain angle, used when processing the victims and doing template matching. <br  />
 <br /></td></tr>
<tr class="separator:ae9bdf2fadfcf7a12d2a22d4b0136a56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa8dca798ff334b12e92b73870aca45dd"><td class="memItemLeft" align="right" valign="top"><a id="aa8dca798ff334b12e92b73870aca45dd"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>DEBUG_plan</b> = false</td></tr>
<tr class="separator:aa8dca798ff334b12e92b73870aca45dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde836d5f98f30b0460816d7e9cfaa4d"><td class="memItemLeft" align="right" valign="top"><a id="acde836d5f98f30b0460816d7e9cfaa4d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>SCALE</b></td></tr>
<tr class="separator:acde836d5f98f30b0460816d7e9cfaa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce878278dd83cdab3ddbb0fbfd0ba62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a5ce878278dd83cdab3ddbb0fbfd0ba62">dubins_primitives_ksigns</a> [6][3]</td></tr>
<tr class="separator:a5ce878278dd83cdab3ddbb0fbfd0ba62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3df385a86baf5326e211215e9e59b9"><td class="memItemLeft" align="right" valign="top"><a id="a4d3df385a86baf5326e211215e9e59b9"></a>
Polygon&#160;</td><td class="memItemRight" valign="bottom"><b>this_borders</b></td></tr>
<tr class="separator:a4d3df385a86baf5326e211215e9e59b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad29d01c42bbbe7cfcd5327f991f369"><td class="memItemLeft" align="right" valign="top"><a id="a9ad29d01c42bbbe7cfcd5327f991f369"></a>
polygon_type&#160;</td><td class="memItemRight" valign="bottom"><b>arena</b></td></tr>
<tr class="separator:a9ad29d01c42bbbe7cfcd5327f991f369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8831c2907627f4f2c91cf27c7c7c796b"><td class="memItemLeft" align="right" valign="top"><a id="a8831c2907627f4f2c91cf27c7c7c796b"></a>
polygon_type&#160;</td><td class="memItemRight" valign="bottom"><b>valid_gate</b></td></tr>
<tr class="separator:a8831c2907627f4f2c91cf27c7c7c796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f219a041f42d14b7e80c3fd23a050af"><td class="memItemLeft" align="right" valign="top"><a id="a8f219a041f42d14b7e80c3fd23a050af"></a>
std::vector&lt; polygon_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boost_obstacle_list</b></td></tr>
<tr class="separator:a8f219a041f42d14b7e80c3fd23a050af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f439833a89e0d71f45a53568b2f560"><td class="memItemLeft" align="right" valign="top"><a id="ac9f439833a89e0d71f45a53568b2f560"></a>
std::vector&lt; Polygon &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>coll_obstacles</b></td></tr>
<tr class="separator:ac9f439833a89e0d71f45a53568b2f560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7872d3ca1e38ee4c16fd3db5577960e2"><td class="memItemLeft" align="right" valign="top"><a id="a7872d3ca1e38ee4c16fd3db5577960e2"></a>
std::vector&lt; Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>full_tree</b></td></tr>
<tr class="separator:a7872d3ca1e38ee4c16fd3db5577960e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac128b14e30411c9bfeaf6989c94a14d9"><td class="memItemLeft" align="right" valign="top"><a id="ac128b14e30411c9bfeaf6989c94a14d9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>SOL_TIME</b> = 1.0</td></tr>
<tr class="separator:ac128b14e30411c9bfeaf6989c94a14d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579efecb6f1e5efff940ec3b3e53a6fc"><td class="memItemLeft" align="right" valign="top"><a id="a579efecb6f1e5efff940ec3b3e53a6fc"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><b>graph_image</b></td></tr>
<tr class="separator:a579efecb6f1e5efff940ec3b3e53a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8310e57d600189e3593de33fc1d29de3"><td class="memItemLeft" align="right" valign="top"><a id="a8310e57d600189e3593de33fc1d29de3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>done</b> = false</td></tr>
<tr class="separator:a8310e57d600189e3593de33fc1d29de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb172f6c2c4c0c49c3eb166ef9e6950"><td class="memItemLeft" align="right" valign="top"><a id="aafb172f6c2c4c0c49c3eb166ef9e6950"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>free_edges</b></td></tr>
<tr class="separator:aafb172f6c2c4c0c49c3eb166ef9e6950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99b5c6c8d97f166a4ff1b9d65357518"><td class="memItemLeft" align="right" valign="top"><a id="aa99b5c6c8d97f166a4ff1b9d65357518"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aa99b5c6c8d97f166a4ff1b9d65357518">DEBUG_Map</a> = false</td></tr>
<tr class="memdesc:aa99b5c6c8d97f166a4ff1b9d65357518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug variable for map processing. <br /></td></tr>
<tr class="separator:aa99b5c6c8d97f166a4ff1b9d65357518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab258fa8d1e2d06180f4917f9d400a696"><td class="memItemLeft" align="right" valign="top"><a id="ab258fa8d1e2d06180f4917f9d400a696"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ab258fa8d1e2d06180f4917f9d400a696">DEBUG_Robot</a> = false</td></tr>
<tr class="memdesc:ab258fa8d1e2d06180f4917f9d400a696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug variable for robot location. <br /></td></tr>
<tr class="separator:ab258fa8d1e2d06180f4917f9d400a696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3822619858f3467801ba8c1aa55fcdd5"><td class="memItemLeft" align="right" valign="top"><a id="a3822619858f3467801ba8c1aa55fcdd5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DEBUG_VICT</b> = false</td></tr>
<tr class="separator:a3822619858f3467801ba8c1aa55fcdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d01d14d5e3e21c24927742f9673da7"><td class="memItemLeft" align="right" valign="top"><a id="a20d01d14d5e3e21c24927742f9673da7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>additional_off</b> = 7</td></tr>
<tr class="separator:a20d01d14d5e3e21c24927742f9673da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main file with the functions required by the simulator. The actual functions called are organized in different files for a cleaner code. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2d7550d88430bcb695137e5976b94e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7550d88430bcb695137e5976b94e3a">&#9670;&nbsp;</a></span>coll_LineCircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::coll_LineCircle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a>&#160;</td>
          <td class="paramname"><em>arc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects collisions between a segment and an arc, identified as a circle </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First x coordinate of the segment </td></tr>
    <tr><td class="paramname">y1</td><td>First y coordinate of the segment </td></tr>
    <tr><td class="paramname">x2</td><td>Second x coordinate of the segment </td></tr>
    <tr><td class="paramname">y2</td><td>Second y coordinate of the segment </td></tr>
    <tr><td class="paramname">arc</td><td><a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the collision check </dd></dl>
<p>Make positive if not</p>
<p>To avoid being considered as collisions</p>
<p>No intersection points found</p>
<p>2 intersection points with circle</p>
<p>1 collision point with circle, delta equal to zero</p>
<p>Find if t1 and t2 are a collision of the actual segment or just of the rect containing it</p>
<p>Real arc collision</p>
<p>Exit, collision found <br  />
</p>
<p>Right turn</p>
<p>Real arc collision</p>
<p>Exit, collision found</p>
<p>Real arc collision</p>
<p>Exit, collision found</p>
<p>Make positive if not</p>
<p>To avoid being considered as collisions</p>
<p>No intersection points found</p>
<p>2 intersection points with circle</p>
<p>1 collision point with circle, delta equal to zero</p>
<p>Find if t1 and t2 are a collision of the actual segment or just of the rect containing it</p>
<p>Real arc collision</p>
<p>Exit, collision found <br  />
</p>
<p>Right turn</p>
<p>Real arc collision</p>
<p>Exit, collision found</p>
<p>Real arc collision</p>
<p>Exit, collision found</p>

</div>
</div>
<a id="a5b674b3695610f840b28b97b1bcd82de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b674b3695610f840b28b97b1bcd82de">&#9670;&nbsp;</a></span>coll_LineLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::coll_LineLine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>COLLISION_CORE</p>
<p>Detects collisions between a couple of segments, and returns the boolean outcome. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First x coordinate of the first segment </td></tr>
    <tr><td class="paramname">y1</td><td>First y coordinate of the first segment </td></tr>
    <tr><td class="paramname">x2</td><td>Second x coordinate of the first segment </td></tr>
    <tr><td class="paramname">y2</td><td>Second y coordinate of the first segment </td></tr>
    <tr><td class="paramname">x3</td><td>First x coordinate of the second segment </td></tr>
    <tr><td class="paramname">y3</td><td>First y coordinate of the second segment </td></tr>
    <tr><td class="paramname">x4</td><td>Second x coordinate of the second segment </td></tr>
    <tr><td class="paramname">y4</td><td>Second y coordinate of the second segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the collision check </dd></dl>

</div>
</div>
<a id="a7e804115ed7fd271368146f5cf78fce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e804115ed7fd271368146f5cf78fce6">&#9670;&nbsp;</a></span>constructArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a> student::constructArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstudent_1_1configuration.html">configuration</a>&#160;</td>
          <td class="paramname"><em>currConf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a> datastructure, which uniquely identifies the arc given its initial and final configurations, its length and curvature. </p>

</div>
</div>
<a id="ac881c09e990c34189df7dee9cd43ed39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac881c09e990c34189df7dee9cd43ed39">&#9670;&nbsp;</a></span>constructDubinsCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstudent_1_1dubinsCurve.html">dubinsCurve</a> student::constructDubinsCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstudent_1_1configuration.html">configuration</a>&#160;</td>
          <td class="paramname"><em>initialConf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs the whole Dubin's curve given the initial configuration, and the precomputed parameters of the three arcs. These are the length of the arcs - s1, s2, s3 - and their curvature - k0, k1, k2. </p>

</div>
</div>
<a id="a1683a6357c9495deae1b46f1f23d716e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1683a6357c9495deae1b46f1f23d716e">&#9670;&nbsp;</a></span>cross2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double student::cross2D </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M_00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M_01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M_10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M_11</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the cross product of a 2-Dimensional matrix. Variables are named after their ficticious index in the matrix. </p>

</div>
</div>
<a id="a1ab33418a119017635f5f69558fd7c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab33418a119017635f5f69558fd7c43">&#9670;&nbsp;</a></span>dot2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double student::dot2D </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M_00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M_01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M_10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M_11</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the dot product of two arrays. Variables are named after their ficticious index in the matrix. </p>

</div>
</div>
<a id="aa356091fcb55ee1924e097c9c97129a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa356091fcb55ee1924e097c9c97129a1">&#9670;&nbsp;</a></span>dubins_LRL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::dubins_LRL </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_th0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_thf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_Kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to implement the finding of the path made of a Left curve, followed by a <br  />
 Right curve, followed by a Left curve. Takes as input the initial and final orientations, and the maximum curvature. It returns the length of the three segments. </p>

</div>
</div>
<a id="a80f21f358569ce086b2be919cd3c7607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f21f358569ce086b2be919cd3c7607">&#9670;&nbsp;</a></span>dubins_LSL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::dubins_LSL </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_th0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_thf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_Kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the computation of the Dubin's curve composed by an arc to the left, then a straight line, then an arc to the left. Takes as input the initial and final orientations, and the maximum curvature. It returns the length of the three segments. </p>

</div>
</div>
<a id="a255f1fd6ee3a8a404469459c51fd8e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255f1fd6ee3a8a404469459c51fd8e76">&#9670;&nbsp;</a></span>dubins_LSR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::dubins_LSR </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_th0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_thf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_Kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the computation to check for the Dubin's curve composed by an arc to the left, then a straight line, then an arc to the right. Takes as input the initial and final orientations, and the maximum curvature. It returns the length of the three segments. </p>

</div>
</div>
<a id="acc22c326309c1c531da2d15d271e009c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc22c326309c1c531da2d15d271e009c">&#9670;&nbsp;</a></span>dubins_RLR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::dubins_RLR </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_th0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_thf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_Kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to implement the finding of the path made of a Right curve, followed by a Left curve, followed by a Right curve. Takes as input the initial and final orientations, and the maximum curvature. It returns the length of the three segments. </p>

</div>
</div>
<a id="ada1e4d5c3ea5d2032812cce24ac5a479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1e4d5c3ea5d2032812cce24ac5a479">&#9670;&nbsp;</a></span>dubins_RSL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::dubins_RSL </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_th0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_thf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_Kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to implement the finding of the path made of a Right curve, followed by a <br  />
 Straight line, followed by a Left curve. Takes as input the initial and final orientations, and the maximum curvature. It returns the length of the three segments. </p>

</div>
</div>
<a id="a79074a60055dba829304da1ba43cfdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79074a60055dba829304da1ba43cfdfb">&#9670;&nbsp;</a></span>dubins_RSR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::dubins_RSR </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_th0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_thf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sc_Kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sc_s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the computation to check for the Dubin's curve composed by an arc to the right, then a straight line, then an arc to the right. Takes as input the initial and final orientations, and the maximum curvature. It returns the length of the three segments. </p>

</div>
</div>
<a id="ad16c5106a18eaaea0d105ba30403eedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16c5106a18eaaea0d105ba30403eedd">&#9670;&nbsp;</a></span>dubins_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, <a class="el" href="structstudent_1_1dubinsCurve.html">dubinsCurve</a> &gt; student::dubins_shortest_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstudent_1_1configuration.html">configuration</a>&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstudent_1_1configuration.html">configuration</a>&#160;</td>
          <td class="paramname"><em>final</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Kmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the Dubins problem for the given input parameters. Return the type and the parameters of the optimal curve. </p>

</div>
</div>
<a id="ae40970d4d45d273f2571d70f5e75a054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40970d4d45d273f2571d70f5e75a054">&#9670;&nbsp;</a></span>getCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point student::getCenter </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Point struct with the coordinates of the passed Polygon's center </p>

</div>
</div>
<a id="a343d9cd6d6fd1747e42374104cee6cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343d9cd6d6fd1747e42374104cee6cba">&#9670;&nbsp;</a></span>getNextConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstudent_1_1configuration.html">configuration</a> student::getNextConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstudent_1_1configuration.html">configuration</a>&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes next configuration given the current one, the length of the arc and the curvature. Applied to get the nextConf in <a class="el" href="structstudent_1_1dubinsArc.html">dubinsArc</a>. </p>

</div>
</div>
<a id="a13283ab20308fde8c6f0175f6c2ddf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13283ab20308fde8c6f0175f6c2ddf44">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double student::max </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>COLLISION_UTILITY </p>

</div>
</div>
<a id="aabfea618c10c13f73ac9e6ddca052db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfea618c10c13f73ac9e6ddca052db2">&#9670;&nbsp;</a></span>missionOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::missionOne </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>RRT_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; ompl::base::SpaceInformation &gt;&#160;</td>
          <td class="paramname"><em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; ob::SE2StateSpace &gt;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the mission one: collect all the victims in order and go to the gate, by avoiding the obstacles. Takes as input: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_list</td><td>The victims, in order, and the gate </td></tr>
    <tr><td class="paramname">RRT_list</td><td>the output list containing a series of states along the path </td></tr>
    <tr><td class="paramname">si</td><td>A variable of OMPL needed by the planner </td></tr>
    <tr><td class="paramname">space</td><td>Another variable of OMPL </td></tr>
    <tr><td class="paramname">image</td><td>An image for debugging purposes. </td></tr>
  </table>
  </dd>
</dl>
<p>Close with the last segment</p>
<p>Free the memory from the previous goal TODO remove</p>
<p>Close with the last segment</p>
<p>Free the memory from the previous goal TODO remove</p>

</div>
</div>
<a id="af0e78c9c1bb3fcd9536f328335d64def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e78c9c1bb3fcd9536f328335d64def">&#9670;&nbsp;</a></span>missionTwo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::missionTwo </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; ompl::base::SpaceInformation &gt;&#160;</td>
          <td class="paramname"><em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trial of implementing mission two, by connecting all the points found in one iteration of the RRTstar between each other (a sort of PRM). </p>

</div>
</div>
<a id="ab3f1d6c8dd4caa817efc0cd3c46eb2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f1d6c8dd4caa817efc0cd3c46eb2e0">&#9670;&nbsp;</a></span>mouseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::mouseCallback </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the selected points into the result variable, for usage by the calibration function. (taken from professor_interface.cpp) </p>

</div>
</div>
<a id="a37eabf8488e510a598c21787bb66cfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eabf8488e510a598c21787bb66cfea">&#9670;&nbsp;</a></span>multipoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structstudent_1_1dubinsCurve.html">dubinsCurve</a> &gt; student::multipoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstudent_1_1configuration.html">configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>robot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gate_th</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the Dubin's shortest path between a list of points, the first of which is the robot and the last of which is the gate. Both brute-froce approach and the optimized/iterative one are implemented. </p>

</div>
</div>
<a id="a6c480ab8ffeff46887387b8b54c4dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c480ab8ffeff46887387b8b54c4dcb9">&#9670;&nbsp;</a></span>myStateValidityCheckerFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::myStateValidityCheckerFunction </td>
          <td>(</td>
          <td class="paramtype">const ob::State *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>State validity checker, used by the sampler in order to see if a point is valid. </p><dl class="section return"><dt>Returns</dt><dd>true if the point is inside the arena and in a free area, or on the gate. False if it is outside the arena or on an obstacle. </dd></dl>

</div>
</div>
<a id="a01244e0e0a28d974de100ffcad7a2583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01244e0e0a28d974de100ffcad7a2583">&#9670;&nbsp;</a></span>pickNPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cv::Point2f&gt; student::pickNPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function which asks the user to select the 4 points to be used for the calibration of the camera (the arena corners). (taken from professor_interface.cpp) </p>

</div>
</div>
<a id="a218f733020135d62f2caa53a28210869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218f733020135d62f2caa53a28210869">&#9670;&nbsp;</a></span>plotXCircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::plotXCircle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>verse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to plot a possible collision between two lines If the image is scaled incorrectly, change the fact variable. </p>
<p>Plot line, circle and the two arc points as circles, the smallest as the starting one.</p>
<p>Left turn</p>
<p>Left turn</p>
<p>Plot line, circle and the two arc points as circles, the smallest as the starting one.</p>
<p>Left turn</p>
<p>Left turn</p>

</div>
</div>
<a id="a7c29d7d15cf5e0736336cb908aaf0c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c29d7d15cf5e0736336cb908aaf0c71">&#9670;&nbsp;</a></span>plotXLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::plotXLine </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>COLLISION_PLOT</p>
<p>Function to plot a possible collision between two lines If the image is scaled incorrectly, change the fact variable. </p>

</div>
</div>
<a id="a4d70460143a4151dd1ef09ee21bbe767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d70460143a4151dd1ef09ee21bbe767">&#9670;&nbsp;</a></span>student_extrinsicCalib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::student_extrinsicCalib </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point3f &gt;&#160;</td>
          <td class="paramname"><em>object_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>tvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of extrinsicCalib() functions. From 4 user-inserted points, it gets an estimate of the arena corners in 3D and computes the rotation and translation vectors to map them into 2D. These will be used to unwarm the image, transforming i t from 3d to 2d in a correct way. (Finds arena pose from 3D(object_points)-2D(image_in) point correspondences.) Returns true if the operation was successful. </p>

</div>
</div>
<a id="a41af80cd00041a3f7159a5d3f4fb6116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41af80cd00041a3f7159a5d3f4fb6116">&#9670;&nbsp;</a></span>student_findPlaneTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::student_findPlaneTransform </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>cam_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>tvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cv::Point3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_points_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest_image_points_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>plane_transf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the findPlanTransform() function of the student_interface. Performs the 3D to 2D transformation of the arena. </p>

</div>
</div>
<a id="a04e9d0633e36ea78c4bb946f593c8f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e9d0633e36ea78c4bb946f593c8f8e">&#9670;&nbsp;</a></span>student_findRobot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::student_findRobot </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polygon &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>DEBUG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Student implementation of the findRobot() function. It processes the blue area of the arena, identifies the triangle which represents the robot, processes it to find its center (x,y) and orientation (theta). If DEBUG is true, more information about the process is printed and images are shown. </p>

</div>
</div>
<a id="a9056dc07d30ae7657be42b03dfe3a2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9056dc07d30ae7657be42b03dfe3a2a0">&#9670;&nbsp;</a></span>student_genericImageListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::student_genericImageListener </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the genericImageListener function from the student_interface. It saves the img_in into the config_folder/camera_image directory, upon request of the user. Press 's' when the image is shown in order to save it. </p>

</div>
</div>
<a id="a187cfd6d82aaffa5c634c4ef24271f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187cfd6d82aaffa5c634c4ef24271f7d">&#9670;&nbsp;</a></span>student_imageUndistort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::student_imageUndistort </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>cam_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>dist_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the imageUndistort() function of student_interface. It takes the img_in and performs the undistortion based on the camera parameters. </p>

</div>
</div>
<a id="a3c8c9cb0a117359291d6800b0dd9461f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8c9cb0a117359291d6800b0dd9461f">&#9670;&nbsp;</a></span>student_loadImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::student_loadImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the loadImage() function of the student_interface. It takes the imges from the config_folder/camera_image folder and loads them into the simulator. </p>

</div>
</div>
<a id="aa3e0aecde54620c30d46a5dcc6c9fb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e0aecde54620c30d46a5dcc6c9fb7a">&#9670;&nbsp;</a></span>student_planPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::student_planPath </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, Polygon &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the computation of a collision free path, that goes through all the victims's in order (mission 1) by using Dubin's manoeuvres. It uses the RRTstar library of OMPL. </p>
<p>Close the arena polygon</p>
<p>Close the obstacle polygon</p>
<p>Close the arena polygon</p>
<p>Close the obstacle polygon</p>

</div>
</div>
<a id="a261bfa62778cb6adf492f7d50827da78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261bfa62778cb6adf492f7d50827da78">&#9670;&nbsp;</a></span>student_processMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::student_processMap </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, Polygon &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polygon &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>DEBUG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the processMap() function of the student_interface. It takes the img_in coming from the simulator or the camera, processes it to find the obstacles that the robot has to avoid and the victims that it needs to save. It uses some helper functions that divide the processing in a more structured way. </p>

</div>
</div>
<a id="a7b33d29b9e4396350ed75aac2ef2d3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b33d29b9e4396350ed75aac2ef2d3ce">&#9670;&nbsp;</a></span>student_unwarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::student_unwarp </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>transf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of the unwarp() function of the student_interface. It performs the last step in image processing which unwarps the image according to the transformation matrix previously computed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5ce878278dd83cdab3ddbb0fbfd0ba62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce878278dd83cdab3ddbb0fbfd0ba62">&#9670;&nbsp;</a></span>dubins_primitives_ksigns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int student::dubins_primitives_ksigns[6][3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        {  1,  0,  1 },     </div>
<div class="line">        { -1,  0, -1 },     </div>
<div class="line">        {  1,  0, -1 },     </div>
<div class="line">        { -1,  0,  1 },     </div>
<div class="line">        { -1,  1, -1 },     </div>
<div class="line">        {  1, -1,  1 }      </div>
<div class="line">    }</div>
</div><!-- fragment --><p>Definition of the curvatue signs corresponding to the different dubins primitives functions. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
